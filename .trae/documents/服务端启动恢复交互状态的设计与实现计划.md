## 目标
- 在服务端启动时从数据库恢复交互状态，确保断电/重启后客户端与服务端逻辑状态一致（任务号、nonce、频控与重复检测）。
- 恢复的范围：最新 `job_id` 与 `server_nonce`、历史任务记录、每用户最新状态（最近提交时间、最新 job/nonce）、已使用的 `client_nonce`（按用户+job）。

## 数据模型（GORM）
- 表与模型：
  - job_history(job_id PK, server_nonce, created_at)
  - user_state(username PK, latest_job_id, latest_server_nonce, last_submit_at)
  - used_nonces(username, job_id, client_nonce, PK(username, job_id, client_nonce))
- 迁移：在启动时 `AutoMigrate` 确保表存在（沿用现有 GORM 初始化）。

## 启动恢复流程
- 读取最新任务：从 `job_history` 取 `MAX(job_id)` 的记录，恢复 `Coordinator.jobID` 与 `serverNonce`。
- 恢复历史：拉取最近 N 条或时间窗口内的 job 记录，填充 `Coordinator.history[job_id] = {nonce, created_at}`；窗口大小可配置（如 `KUP_HISTORY_WINDOW=24h`）。
- 会话恢复策略：
  - 网络连接不可恢复（TCP 通道是短暂的）。
  - 在客户端授权时（Accept/RegisterSession），根据 `user_state` 为该用户名恢复 `LatestJobID/LatestServerNonce/LastSubmitAt`，并按 `used_nonces` 填充该用户在相关 job 下的已用 nonce 集合。

## 运行时持久化
- 广播任务：在 `Coordinator.rotateJob()` 后持久化到 `job_history`；并更新内存 history。
- 结果提交：在 `Listener.handleSubmit()` 校验通过后：
  - 写入 `used_nonces(username, job_id, client_nonce)`（防重复跨重启生效）。
  - 更新 `user_state(username)` 的 `latest_job_id/latest_server_nonce/last_submit_at`。
- 读路径优化：重复检测先查内存 `UsedNonces`，命中失败时从 `used_nonces` 二次确认（避免冷启动时误判）。

## 代码改造点
- 新建持久化接口（StateStore）与实现（基于 GORM）：
  - SaveJob/LoadLatestJob/LoadJobHistory(limit/window)
  - LoadUserState/SaveUserState
  - SaveUsedNonce/HasUsedNonce
- 接入位置：
  - `NewAppServer`/`Start`：执行启动恢复，填充 `Coordinator.jobID/serverNonce/history`。
  - `Acceptor.RegisterSession`：按 `username` 加载并填充会话状态与已用 nonce。
  - `Coordinator.rotateJob/broadcastJob`：保存 job 历史。
  - `Listener.handleSubmit`：保存 used nonce 与更新 user_state。
- 错误处理：
  - 恢复失败日志化并采用安全默认（jobID=0，无 history）；运行时持久化失败时仍保证内存更新，不阻断业务。

## 关闭与一致性
- 与现有优雅关闭相衔接：
  - 消费 MQ 的处理在提交时即写入状态表，不需要额外恢复。
  - 关闭时保证所有持久化操作完成（已有 WaitGroup）。

## 管理与验证
- 管理接口扩展（可选）：
  - `GET /state/meta` 返回当前 `job_id/server_nonce` 与历史窗口摘要。
  - `GET /state/user?username=...` 返回该用户的 `last_submit_at` 与最近 N 个 used nonces（仅摘要）。
- 测试：
  - 启动→提交→重启→重复提交检查仍能命中（Duplicate submission）。
  - 恢复后的广播从已持久化的 `job_id`+1 继续；历史任务正确加载。

## 交付策略
- 增加 GORM 模型与迁移、实现 StateStore 并接入现有流程。
- 参数化恢复窗口与限制（环境变量/flag）。
- 保持最小侵入：不改变外部协议与现有接口签名，内部在会话注册与监听器中注入持久化逻辑。